/* A simple 1st order 1/2 Interpreter for a functional language *//* inspired by Clocksin, Clause and Effect */:- op(600,yfx,'@')./* eval(F,Z) :- print(eval(F)),nl,fail. */eval('@'(callout,[Op,X,Y]),Z) :-	eval(X,X1),eval(Y,Y1),	callout(Op,X1,Y1,Z).eval('@'(if,[C,T,E]),Z) :-	eval(C,C1),	auxif(C1,T,E,A),	eval(A,Z).eval(Constr,Z) :-	constructor(Constr,C,Args),	l_eval(Args,Args1),	Z =.. [C|Args1].eval('@'(F,A),Z) :-	fun('@'(F,A1),FDef),	l_eval(A,A1),	eval(FDef,Z).l_eval([],[]).l_eval([H|T],[EH|ET]) :-	eval(H,EH), l_eval(T,ET).constructor([],[],[]).constructor([H|T],'.',[H,T]).constructor(tree(L,I,R),tree,[L,I,R]).constructor(true,true,[]).constructor(false,false,[]).constructor(X,X,[]) :- number(X).constructor(F,F,[]) :- fun('@'(F,_),_).constructor(s(X),s,[X]).data_expr(X) :- constructor(X,C,A), l_data(A).l_data([]).l_data([H|T]) :- data_expr(H),l_data(T).auxif(true,X,_,X).auxif(false,_,X,X).t(X) :- eval('@'(plus,[2,3]),X).m(X,R) :- eval('@'(map,[inc,X]),R).ms(X,R) :- eval('@'(map,[sinc,X]),R).m2(X,R) :- eval('@'(map,[sqr,X]),R).inv(X,Z) :- eval('@'(sinc,[X]),Z),data_expr(X).inv2(X) :- ms(X,[s(0),s(s(0))]),data_expr(X)./* inv(X,s(0)) -> ECCE 2x  inv(0,s(0)). *//* FUNCTION DEFINITIONS */fun('@'(plus,[X,Y]),'@'(callout,['+',X,Y])).fun('@'(inc,[X]),'@'(callout,['+',X,1])).fun('@'(sqr,[X]),'@'(callout,['*',X,X])).fun('@'(sinc,[X]),s(X)).fun('@'(map,[F,L]),	'@'(if,[ '@'(callout,['=',L,[]]),		[],		['@'(F,['@'(hd,[L])]) | '@'(map,[F,'@'(tl,[L])]) ]	   ])    ).fun('@'(hd,[[X|_]]),X).fun('@'(tl,[[_|T]]),T)./* BUILT-IN FUNCTIONS */callout('+',X,Y,Z) :- Z is X + Y.callout('*',X,Y,Z) :- Z is X * Y.callout('-',X,Y,Z) :- Z is X - Y.callout('/',X,Y,Z) :- Z is X / Y.callout('=',X,X,true).callout('=',X,Y,false) :- X \= Y.