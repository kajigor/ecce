# ------------------------------------------------------------
# GUI Section
# ------------------------------------------------------------

# -------
# procedure to initialise menu section
# -------
proc procGUI_Menu {} {
    
    # top level menu bar

    menu .menubar -tearoff 0
    . config -menu .menubar
    foreach m {File Analyse Settings Postprocessing About} {
        set $m [menu .menubar.mnu$m -tearoff 0]
        .menubar add cascade -label $m -menu .menubar.mnu$m
    }
       
#    .menubar.mnuFile -text "File" \
#       -menu .mnuFile -underline 0 
       
#    .menubar.mnuAnalyse -text "Analyse" \
#       -menu .mnuAnalyse
       
#    menu .mnuSettings -text "Settings" \
#       -menu .mnuSettings
       
#    menu .mnuOptions -text "Postprocessing" \
#       -menu .mnuOptions.m

#    menu .mnuAbout -text "About" \
#       -menu .mnuAbout -underline 0 
       
    # -------------------- append to the menu bar
#    pack append  \
#      .menubar.mnuFile {left frame w} \
#      .menubar.mnuAnalyse {left frame w} \
#      .menubar.mnuSettings {left frame w} \
#      .menubar.mnuOptions {left frame w} \
#      .menubar.mnuAbout {right frame w}
    
  
    # -------------------- file menu
#    menu .menubar.mnuFile -tearoff 0
    .menubar.mnuFile add command -label "Open..." -command procOpenFile -accelerator Meta+o
    .menubar.mnuFile add command -label "Reopen" -command procReOpenFile -state disabled
    .menubar.mnuFile add command -label "Open Destination File" \
         -command procOpenDestFile -state disabled
    .menubar.mnuFile add sep
    .menubar.mnuFile add command -label "Quit" -command {destroy .} -accelerator Meta+q
    
   bind . <Meta-o> {procOpenFile}
   bind . <Meta-r> {procReOpenFile}
   bind . <Meta-q> {destroy .}

    # -------------------- Analyse menu
#    menu .menubar.mnuAnalyse -tearoff 0
   .menubar.mnuAnalyse add command -label "Bottom-Up MSV Analysis" \
       -command procMSVAnalysisOnSource -state disabled
    .menubar.mnuAnalyse add sep
   .menubar.mnuAnalyse add command -label "RAF Analysis using Goal" \
       -command procRAFAnalysis -state disabled
   .menubar.mnuAnalyse add command -label "FAR Filtering" \
      -command procFARAnalysis -state disabled
    .menubar.mnuAnalyse add sep
   .menubar.mnuAnalyse add command -label "Display Specialisation Tree" \
       -command procDisplayLocalTrees -state disabled
   .menubar.mnuAnalyse add cascade -label "Display Settings" \
        -menu .menubar.mnuAnalyse.mnuGTOptions
    .menubar.mnuAnalyse add sep
   .menubar.mnuAnalyse add command -label "Slice" \
      -command procSlice -state disabled
   
   
    # -------------------- Display Global Tree Options menu
    menu .menubar.mnuAnalyse.mnuGTOptions -tearoff 0
    global gt_dot_display_instances
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Display Instance Relationships" \
         -variable gt_dot_display_instances -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
    global gt_dot_display_localtrees
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Display Local Trees" \
         -variable gt_dot_display_localtrees -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
    global gt_dot_put_code_nodes_same_rank
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Rank nodes of same type" \
         -variable gt_dot_put_code_nodes_same_rank -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
    global gtLeaves
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Display Leaves" \
         -variable gtLeaves -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
    global gtNodeIds
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Display Node IDs" \
         -variable gtNodeIds -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
    global gt_adorn_edges
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Colour and Label Edges" \
         -variable gt_adorn_edges -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
    global gtAutoGenerateDot 
   .menubar.mnuAnalyse.mnuGTOptions add checkbutton -label "Automatically Generate in tmp" \
         -variable gtAutoGenerateDot -offvalue 0 -onvalue 1 -command {procUpdateEcceGTOptions}
   .menubar.mnuAnalyse.mnuGTOptions add sep
   .menubar.mnuAnalyse.mnuGTOptions add cascade -label "Viewer" \
        -menu .menubar.mnuAnalyse.mnuViewer
    
    # -------------------- Dot Viewer menu
    global gtUsePSViewer
    #if {$tcl_platform(os)=="Windows"} {set gtUsePSViewer 3} else {set gtUsePSViewer 0}
    set gtUsePSViewer 0
    menu .menubar.mnuAnalyse.mnuViewer -tearoff 0
   .menubar.mnuAnalyse.mnuViewer add radiobutton -label "Dotty" \
         -variable gtUsePSViewer -value 0
   .menubar.mnuAnalyse.mnuViewer add radiobutton -label "GV" \
         -variable gtUsePSViewer -value 1
   .menubar.mnuAnalyse.mnuViewer add radiobutton -label "MacGhostViewX" \
         -variable gtUsePSViewer -value 2
   .menubar.mnuAnalyse.mnuViewer add radiobutton -label "GSView32" \
         -variable gtUsePSViewer -value 3
         
    # -------------------- Settings menu
#    menu .menubar.mnuSettings -tearoff 0
   .menubar.mnuSettings add cascade -label "Unfold Settings" \
        -menu .menubar.mnuSettings.mnuUnfold
   .menubar.mnuSettings add cascade -label "Whistle Settings" \
        -menu .menubar.mnuSettings.mnuWhistle
   .menubar.mnuSettings add cascade -label "Abstraction Settings" \
        -menu .menubar.mnuSettings.mnuAbstract
   .menubar.mnuSettings add cascade -label "Instance Check Settings" \
        -menu .menubar.mnuSettings.mnuInstCheck
   .menubar.mnuSettings add cascade -label "Pre-Defined Settings" \
        -menu .menubar.mnuSettings.mnuPredefined
   .menubar.mnuSettings add command -label "Turn Debugging Checks off" \
         -command {prolog "tcltk_turn_type_checking_off"}
  
    # -------------------- Unfold menu
    global unfoldVal
    set unfoldVal 0
    menu .menubar.mnuSettings.mnuUnfold -tearoff 0
   .menubar.mnuSettings.mnuUnfold add radiobutton -label "Determinate" \
         -variable unfoldVal -value 0 \
         -command {prolog "set_parameter(selectionrule,116)"}
   .menubar.mnuSettings.mnuUnfold add radiobutton -label "Homeomorphic" \
         -variable unfoldVal -value 1 \
         -command {prolog "set_parameter(selectionrule,105)"}
   .menubar.mnuSettings.mnuUnfold add radiobutton -label "Every Pred Once" \
         -variable unfoldVal -value 2 \
         -command {prolog "set_parameter(selectionrule,101)"}
   .menubar.mnuSettings.mnuUnfold add radiobutton -label "Just Once" \
         -variable unfoldVal -value 3 \
         -command {prolog "set_parameter(selectionrule,99)"}
   .menubar.mnuSettings.mnuUnfold add radiobutton -label "Mixtus" \
         -variable unfoldVal -value 4 \
         -command {prolog "set_parameter(selectionrule,120)"}
    .menubar.mnuSettings.mnuUnfold add sep
   .menubar.mnuSettings.mnuUnfold add radiobutton -label "one left-most non-det step homeomorphic unfolding" \
         -variable unfoldVal -value 4 \
         -command {prolog "set_parameter(selectionrule,111)"}
         
    # -------------------- Whistle menu
    global whistleVal
    set whistleVal 0
    menu .menubar.mnuSettings.mnuWhistle -tearoff 0
   .menubar.mnuSettings.mnuWhistle add radiobutton -label "Homeo(Tree) + Termsize(Conj)" \
         -variable whistleVal -value 0 \
         -command {prolog "set_parameter(whistle,102)"}
   .menubar.mnuSettings.mnuWhistle add radiobutton -label "Homeo(Conj)" \
         -variable whistleVal -value 1 \
         -command {prolog "set_parameter(whistle,99)"}
   .menubar.mnuSettings.mnuWhistle add radiobutton -label "Not More General than Ancestor" \
         -variable whistleVal -value 2 \
         -command {prolog "set_parameter(whistle,109)"}
         
    # -------------------- Abstraction menu
    global abstractVal
    set abstractVal 0
    menu .menubar.mnuSettings.mnuAbstract -tearoff 0
   .menubar.mnuSettings.mnuAbstract add radiobutton -label "Msg with Termsize Emb. SubConj" \
         -variable abstractVal -value 0 \
         -command {prolog "set_parameter(abstraction,108)"}
   .menubar.mnuSettings.mnuAbstract add radiobutton -label "Msg" \
         -variable abstractVal -value 1 \
         -command {prolog "set_parameter(abstraction,109)"}
   .menubar.mnuSettings.mnuAbstract add radiobutton -label "Naive Msg" \
         -variable abstractVal -value 2 \
         -command {prolog "set_parameter(abstraction,110)"}
   .menubar.mnuSettings.mnuAbstract add radiobutton -label "Msg + RUL shortening" \
         -variable abstractVal -value 3 \
         -command {prolog "set_parameter(abstraction,112)"}
         
    # -------------------- Instance Chekc menu
    global instCheckVal
    set instCheckVal 2
    menu .menubar.mnuSettings.mnuInstCheck -tearoff 0
   .menubar.mnuSettings.mnuInstCheck add radiobutton -label "Any instance of a goal" \
         -variable instCheckVal -value 0 \
         -command {prolog "set_parameter(instchecks,97)"}
   .menubar.mnuSettings.mnuInstCheck add radiobutton -label "Instance of a goal with same chtree" \
         -variable instCheckVal -value 1 \
         -command {prolog "set_parameter(instchecks,105)"}
   .menubar.mnuSettings.mnuInstCheck add radiobutton -label "Variant of a goal with same chtree" \
         -variable instCheckVal -value 2 \
         -command {prolog "set_parameter(instchecks,118)"}
   .menubar.mnuSettings.mnuInstCheck add radiobutton -label "Variant + chtree + Karp Miller" \
         -variable instCheckVal -value 3 \
         -command {prolog "set_parameter(instchecks,121)"}
         
    # -------------------- Pre-Defined menu
    
    menu .menubar.mnuSettings.mnuPredefined -tearoff 0
   .menubar.mnuSettings.mnuPredefined add command -label "Turn RUL on" -command procTurnRULon
   .menubar.mnuSettings.mnuPredefined add command -label "Turn RUL with BUP on" -command procTurnRULBUPon
   .menubar.mnuSettings.mnuPredefined add sep
   .menubar.mnuSettings.mnuPredefined add command -label "Best Standard PD" \
         -command {prolog "set_standard_config(98)"}
   .menubar.mnuSettings.mnuPredefined add command -label "Fast Conjunctive PD" \
         -command {prolog "set_standard_config(100)"}
   .menubar.mnuSettings.mnuPredefined add command -label "Deforestation" \
         -command {prolog "set_standard_config(103)"}
   .menubar.mnuSettings.mnuPredefined add sep
   .menubar.mnuSettings.mnuPredefined add command -label "Karp-Miller" \
         -command {prolog "set_standard_config(121)"}
   .menubar.mnuSettings.mnuPredefined add command -label "Finkel" \
         -command {prolog "set_standard_config(122)"}
         
         
    # -------------------- Options menu
#    menu .menubar.mnuPostprocessing -tearoff 0
    global ppRAF
   .menubar.mnuPostprocessing add checkbutton -label "RAF Filtering" \
         -variable ppRAF -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
    global ppFAR
   .menubar.mnuPostprocessing add checkbutton -label "FAR Filtering" \
         -variable ppFAR -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
    global ppDCE
   .menubar.mnuPostprocessing add checkbutton -label "Dead Code Elimination" \
         -variable ppDCE -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
    global ppRRC
   .menubar.mnuPostprocessing add checkbutton -label "Remove Redundant Calls" \
         -variable ppRRC -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
    global ppDPU
   .menubar.mnuPostprocessing add checkbutton -label "Determinate Post-Unfolding" \
         -variable ppDPU -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
    global ppRPV
   .menubar.mnuPostprocessing add checkbutton -label "Reduce Polyvariance" \
         -variable ppRPV -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
    global ppMSV
   .menubar.mnuPostprocessing add checkbutton -label "Bottom-Up MSV phase" \
         -variable ppMSV -offvalue 0 -onvalue 1 -command {procUpdateEcceOptions}
   .menubar.mnuPostprocessing add sep
   .menubar.mnuPostprocessing add command -label "Turn all off" -command {procTurnPPOff}
   .menubar.mnuPostprocessing add command -label "Turn all on" -command {procTurnPPOn}
    
    # -------------------- About menu
#    menu .menubar.mnuAbout -tearoff 0
    .menubar.mnuAbout add command -label "About ECCE" -command "procAboutEcce" -underline 0
   

    # ----- fix the menu bar
#    pack append .  {top fillx}
}


proc procEnableItemsAfterSpecialisation {} {
    # enable Open Destination File
    .menubar.mnuFile entryconfigure 2 -state normal
    # enable Display Global Tree & Local Trees
    .menubar.mnuAnalyse entryconfigure 5 -state normal
    # enable Slice
    .menubar.mnuAnalyse entryconfigure 8 -state normal

}

proc procEnableItemsAfterOpeningFile {} {
    global strFilename
	# enable ReOpen and Specialise Button
	set fileTail [file tail $strFilename]
	.menubar.mnuFile entryconfigure 1 -state normal \
	   -label "Reopen $fileTail"
	
	.frmSpec.b1 configure -state normal
	# enable Analyse menu items
	.menubar.mnuAnalyse entryconfigure 0 -state normal
	.menubar.mnuAnalyse entryconfigure 2 -state normal
	.menubar.mnuAnalyse entryconfigure 3 -state normal

}

# -------

proc procTurnRULon {} {
   prolog tcltk_turn_rul_on
   procUpdateOptionsMenu
}


proc procTurnRULBUPon {} {
   prolog tcltk_turn_rul_bup_on
   procUpdateOptionsMenu
}

proc procTurnPPOff {} {
  global ppRAF ppFAR ppDCE ppRRC ppDPU ppRPV ppMSV
  
  set ppRAF 0
  set ppFAR 0
  set ppDCE 0
  set ppRRC 0
  set ppDPU 0
  set ppRPV 0
  set ppMSV 0
  procUpdateEcceOptions
}

proc procTurnPPOn {} {
  global ppRAF ppFAR ppDCE ppRRC ppDPU ppRPV ppMSV
  
  set ppRAF 1
  set ppFAR 1
  set ppDCE 1
  set ppRRC 1
  set ppDPU 1
  set ppRPV 1
  set ppMSV 1
   
}

proc procUpdateOptionsMenu {} {
  global ppRAF ppFAR ppDCE ppRRC ppDPU ppRPV ppMSV
   if {[prolog "perform_raf(yes)"]} {set ppRAF 1} else {set ppRAF 0}
   if {[prolog "perform_far(yes)"]} {set ppFAR 1} else {set ppFAR 0}
   if {[prolog "perform_dce(yes)"]} {set ppDCE 1} else {set ppDCE 0}
   if {[prolog "allow_removal_of_duplicate_predicates(yes)"]} {
      set ppRRC 1} else {set ppRRC 0}
   if {[prolog "perform_determinate_post_unfolding(yes)"]} {set ppDPU 1} else {set ppDPU 0}
   if {[prolog "current_reduce_polyvariance(121)"]} {
      set ppRPV 1} else {set ppRPV 0}
   if {[prolog "perform_post_msv_analysis(yes)"]} {set ppMSV 1} else {set ppMSV 0}
}

proc procUpdateEcceOptions {} {
  global ppRAF ppFAR ppDCE ppRRC ppDPU ppRPV ppMSV
   if {$ppRAF==1} {
      prolog "set_perform_raf(yes)"
   } else {
      prolog "set_perform_raf(no)"
   }
   if {$ppFAR==1} {
      prolog "set_perform_far(yes)"
   } else {
      prolog "set_perform_far(no)"
   }
   if {$ppDCE==1} {
      prolog "set_perform_dce(yes)"
   } else {
      prolog "set_perform_dce(no)"
   }
   if {$ppRRC==1} {
      prolog "set_perform_rrc(yes)"
   } else {
      prolog "set_perform_rrc(no)"
   }
   if {$ppDPU==1} {
      prolog "set_perform_determinate_post_unfolding(yes)"
   } else {
      prolog "set_perform_determinate_post_unfolding(no)"
   }
   if {$ppRPV==1} {
      prolog "set_current_reduce_polyvariance(121)"
   } else {
      prolog "set_current_reduce_polyvariance(110)"
   }
   if {$ppMSV==1} {
      prolog "set_perform_post_msv_analysis(yes)"
   } else {
      prolog "set_perform_post_msv_analysis(no)"
   }
}


# -------
# procedure to initialise source code section
# -------
proc procGUI_Source {} {
    # ------- code source frames
    frame .frmSource -borderwidth .1c -relief groove
    scrollbar .frmSource.scrolly -command ".frmSource.text yview"
    scrollbar .frmSource.scrollx -command ".frmSource.text xview" -orient h
    text .frmSource.text -yscroll ".frmSource.scrolly set" -xscroll ".frmSource.scrollx set" \
        -setgrid 1 -height 18 -state disabled
    pack .frmSource.scrolly -side right -fill y
    pack .frmSource.scrollx -side bottom -fill x
    pack .frmSource.text -expand 1 -fill both
    
    # set up a row to enter specialisation goal and specialise button
    set f [frame .frmSpec]
    pack [label $f.label -text {Goal: }] -side left
    pack [entry $f.entry] -side left -fill x -expand true
    button $f.b1 -text Specialise -default active -state disabled -command {procSpecialise}
    pack $f.b1 -padx 10 -side right
    $f.entry insert 0 {test(a,X)}
    
    # ------- code source frames
    frame .frmDest -borderwidth .1c -relief groove
    scrollbar .frmDest.scrolly -command ".frmDest.text yview"
    scrollbar .frmDest.scrollx -command ".frmDest.text xview" -orient h
    text .frmDest.text -yscroll ".frmDest.scrolly set" -xscroll ".frmDest.scrollx set" \
        -setgrid 1 -height 18 -state disabled
    pack .frmDest.scrolly -side right -fill y
    pack .frmDest.scrollx -side bottom -fill x
    pack .frmDest.text -expand 1 -fill both
}

# -------
# procedure to initialise main GUI
# -------
proc procInitGUI {} {
    wm title . "ECCE - (c) Michael Leuschel"
    wm iconname . "ECCE"

    procGUI_Menu
    procGUI_Source

    # ------- arrange all top frames
    pack .frmDest .frmSpec .frmSource -side bottom -expand yes -pady 1 -fill both
    
    procUpdateOptionsMenu
    procUpdateGTOptionsMenu
    procAboutEcce
}

# -------
# procedure to open a file, and then execute it on prolog
# -------
proc procOpenFile {} {
    global strFilename
    set types {
    	{"Prolog/Ecce Files"		{.pl .pro .P .xce}	}
    	{"Sicstus Files"		{.pl}	}
    	{"XSB Files"		{.P}	}
    	{"BIM Files"		{.pro}	}
    	{"Ecce Files"		{.xce}	}
	    {"All files"		*}
    }
    # show the dialog box
    set strFilename [tk_getOpenFile -filetypes $types -parent . ]
    if {$strFilename != ""} {
        procLoadFile
    }
}


proc procLoadFile {} {
    global strFilename
    if [file exists $strFilename] {
        # frame .progress -borderwidth .1c  -relief groove
        # message .progress.msg -text "Compiling $strFilename"
        # pack configure .progress .progress.msg -fill x
         # raise .progress
	        wm title . "ECCE: \[[file tail $strFilename]\] : (c) Michael Leuschel"
            # the file exists, so load it.
            procShowSourceCode $strFilename
            
        procEnableItemsAfterOpeningFile
    
        } else {
	        tk_messageBox -parent . -icon error \
        		-message "File $strFilename does not exist."
        }
}

# ---------------------------------------------- reload
proc procReOpenFile {} {
    global strFilename
    if {$strFilename != ""} {
        procLoadFile
    }
}

# ---------------------------------------------- load destination
proc procOpenDestFile {} {
    global strFilename
    if {$strFilename != ""} {
        #set rootName [file rootname $strFilename]
        set specName {}
        append specName $strFilename ".xce"
        set strFilename $specName
        procLoadFile
    }
}



# -------
# procedure to reset the animation
# -------
proc procSpecialise {} {
    global strFilename
    #set rootName [file rootname $strFilename]
    set specName {}
    append specName $strFilename ".xce"
    set goal [.frmSpec.entry get]
    #puts "Specialising $strFilename for $goal"
    prolog "tcltk_open('$strFilename')"
    prolog "tcltk_set_specfile('$specName')"
    prolog "tcltk_specialise($goal)"
    procShowDestCode $specName
}


proc procMSVAnalysisOnSource {} {
    global strFilename
    set rootName [file rootname $strFilename]
    set specName {}
    append specName $rootName ".xce"
    prolog "tcltk_open('$strFilename')"
    prolog "tcltk_set_specfile('$specName')"
    prolog "run_msv_anlysis"
    prolog "print_specialised_msv_program_to_file"
    #if {[prolog msv_change]} {puts "change"} else {puts "no change"}
    procShowDestCode $specName
}

proc procRAFAnalysis {} {
    global strFilename
    set rootName [file rootname $strFilename]
    set specName {}
    append specName $rootName ".xce"
    prolog "tcltk_open('$strFilename')"
    prolog "tcltk_set_specfile('$specName')"
    set goal [.frmSpec.entry get]
    prolog "perform_raf_analysis($goal)"
    procShowDestCode $specName
}
proc procFARAnalysis {} {
    global strFilename
    set rootName [file rootname $strFilename]
    set specName {}
    append specName $rootName ".xce"
    prolog "tcltk_open('$strFilename')"
    prolog "tcltk_set_specfile('$specName')"
    prolog "perform_andprint_far_analysis"
    procShowDestCode $specName
}

proc procSlice {} {
    global strFilename
    set rootName [file rootname $strFilename]
    prolog "tcltk_open('$strFilename')"
    prolog "print_slice"
    procShowDestCode $strFilename
    .frmDest.text configure -state normal
    
    prolog "tcltk_get_slices_to_remove(Beg,End)"
    set BegList $prolog_variables(Beg)
    set EndList $prolog_variables(End)
    
    set k 0
    
    foreach i $BegList {
      set j [lindex $EndList $k]
      # puts "delete $i - $j\n"
      .frmDest.text delete $i.0 $j.end
      set k [expr $k+1]
    }
    .frmDest.text configure -state disabled
    
    # Save to special file:
    
    set rootName [file rootname $strFilename]
    set sliceName {}
    append sliceName $rootName ".slice"
    puts "Saving to $sliceName"
	set text [.frmDest.text get 1.0 "end - 1 chars"]
	#output to file here instead
	set fid [open $sliceName w]
	puts -nonewline  $fid $text    
	# seems to add extra blank lines at the end ?!
	close $fid
}

# ------------------------------------------------------------
# Global Tree Section
# ------------------------------------------------------------

proc procDisplayGlobalTree {} {
    global strFilename
    set rootName [file rootname $strFilename]
    set dotName {}
    set psName {}
    append dotName $rootName ".xce.dot"
    append psName $rootName ".xce.ps"
    prolog "gt_generate_dot_file('$dotName')"
    exec dot -Tps $dotName -o $psName
    exec gv $psName &
}


proc procDisplayLocalTrees {} {
    global strFilename
    set rootName [file rootname $strFilename]
    set dotName {}
    set psName {}
    append dotName $rootName ".xce.dot"
    append psName $rootName ".xce.ps"
    prolog "tcltk_open('$strFilename')"
    prolog "unfold_generate_dot_file('$dotName')"
    procVisualiseDotFile $dotName $psName
}

proc procVisualiseDotFile {dotName psName} {
    global gtUsePSViewer
    if {$gtUsePSViewer > 0} {
        exec dot -Tps $dotName -o $psName
        procOpenPSFile $psName
    } else {
        exec dotty $dotName &
    }
}

proc procOpenPSFile {psName} {
    global gtUsePSViewer
    if {$gtUsePSViewer == 1} {
       exec gv $psName &
    } elseif {$gtUsePSViewer == 2} {
       exec open -a /Applications/MacGhostViewX_Folder/MacGhostViewX.app $psName &
    } else {
      exec C:/Ghostgum/gsview/gsview32 $psName
    }
}




proc procUpdateGTOptionsMenu {} {
  global gtLeaves gtNodeIds gtAutoGenerateDot gt_dot_display_instances gt_dot_display_localtrees
  global gt_dot_put_code_nodes_same_rank gt_adorn_edges
   if {[prolog "generate_dot_nodes_for_leaves(yes)"]} {set gtLeaves 1} else {set gtLeaves 0}
   if {[prolog "gt_print_node_ids(yes)"]} {set gtNodeIds 1} else {set gtNodeIds 0}
   if {[prolog "gt_adorn_edges(yes)"]} {set gt_adorn_edges 1} else {set gt_adorn_edges 0}
   if {[prolog "gt_dot_put_code_nodes_same_rank(yes)"]} {set gt_dot_put_code_nodes_same_rank 1} else {set gt_dot_put_code_nodes_same_rank 0}
   if {[prolog "gt_dot_display_localtrees(yes)"]} {set gt_dot_display_localtrees 1} else {set gt_dot_display_localtrees 0}
   if {[prolog "gt_dot_display_instances(yes)"]} {set gt_dot_display_instances 1} else {set gt_dot_display_instances 0}
   if {[prolog "auto_generate_dot_files(yes)"]} {set gtAutoGenerateDot 1} else {set gtAutoGenerateDot 0}
}

proc procUpdateEcceGTOptions {} {
  global gtLeaves gtNodeIds gtAutoGenerateDot gt_dot_display_instances gt_dot_display_localtrees
  global gt_dot_put_code_nodes_same_rank gt_adorn_edges
   if {$gtLeaves==1} {
      prolog "set_generate_dot_nodes_for_leaves(yes)"
   } else {
      prolog "set_generate_dot_nodes_for_leaves(no)"
   }
   if {$gtNodeIds==1} {
      prolog "set_gt_print_node_ids(yes)"
   } else {
      prolog "set_gt_print_node_ids(no)"
   }
   if {$gtAutoGenerateDot==1} {
      prolog "set_auto_generate_dot_files(yes)"
   } else {
      prolog "set_auto_generate_dot_files(no)"
   }
   if {$gt_dot_display_instances==1} {
      prolog "set_gt_dot_display_instances(yes)"
   } else {
      prolog "set_gt_dot_display_instances(no)"
   }
   if {$gt_dot_display_localtrees==1} {
      prolog "set_gt_dot_display_localtrees(yes)"
   } else {
      prolog "set_gt_dot_display_localtrees(no)"
   }
   if {$gt_dot_put_code_nodes_same_rank==1} {
      prolog "set_gt_dot_put_code_nodes_same_rank(yes)"
   } else {
      prolog "set_gt_dot_put_code_nodes_same_rank(no)"
   }
   if {$gt_adorn_edges==1} {
      prolog "set_gt_adorn_edges(yes)"
   } else {
      prolog "set_gt_adorn_edges(no)"
   }
}

# ------------------------------------------------------------
# Functional  Section
# ------------------------------------------------------------
# -------
# procedure to open a file, and put it on the source code
# -------
proc procShowSourceCode {sFileName} {
    .frmSource.text configure -state normal
    .frmSource.text delete 0.0 end
    # open file
    set fid [open $sFileName r]
    .frmSource.text insert 0.0 [read $fid]    
    close $fid
    .frmSource.text configure -state disabled
}


proc procShowDestCode {sFileName} {
    .frmDest.text configure -state normal
    .frmDest.text delete 0.0 end
    # open file
    set fid [open $sFileName r]
    .frmDest.text insert 0.0 [read $fid]    
    close $fid
    .frmDest.text configure -state disabled
    procEnableItemsAfterSpecialisation
}




# A simple Dialog
# ---------------

proc Dialog_Create {top title args} {
	global dialog
	if [winfo exists $top] {
		switch -- [wm state $top] {
			normal {
				# Raise a buried window
				raise $top
			}
			withdrawn -
			iconified {
				# Open and restore geometry
				wm deiconify $top
				catch {wm geometry $top $dialog(geo,$top)}
			}
		}
		return 0
	} else {
		eval {toplevel $top} $args
		wm title $top $title
		return 1
	}
}
proc Dialog_Wait {top varName {focus {}}} {
	upvar $varName var

	# Poke the variable if the user nukes the window
	bind $top <Destroy> [list set $varName $var]

	# Grab focus for the dialog
	if {[string length $focus] == 0} {
		set focus $top
	}
	set old [focus -displayof $top]
	focus $focus
	catch {tkwait visibility $top}
	catch {grab $top}

	# Wait for the dialog to complete
	tkwait variable $varName
	catch {grab release $top}
	focus $old
}
proc Dialog_Dismiss {top} {
	global dialog
	# Save current size and position
	catch {
		# window may have been deleted
		set dialog(geo,$top) [wm geometry $top]
		wm withdraw $top
	}
}


#
# Example 33-2
# A simple dialog.
#

proc Dialog_Prompt { string } {
	global prompt
	destroy .prompt
	set f .prompt
	if [Dialog_Create $f "Prompt" -borderwidth 10] {
		message $f.msg -text $string -aspect 1000
		entry $f.entry -textvariable prompt(result)
		set b [frame $f.buttons]
		pack $f.msg $f.entry $f.buttons -side top -fill x
		pack $f.entry -pady 5
		button $b.ok -text OK -command {set prompt(ok) 1}
		button $b.cancel -text Cancel \
			-command {set prompt(ok) 0}
		pack $b.ok -side left
		pack $b.cancel -side right
		bind $f.entry <Return> {set prompt(ok) 1 ; break}
		bind $f.entry <Control-c> {set prompt(ok) 0 ; break}
	}
	set prompt(ok) 0
	Dialog_Wait $f prompt(ok) $f.entry
	Dialog_Dismiss $f
	if {$prompt(ok)} {
		return $prompt(result)
	} else {
		return {}
	}
}

# ------------------------------------------------------------

proc Create_Settings_Dialog {} {
   toplevel .settingsDlg -borderwidth 10
   
    # set up a row to enter specialisation goal and specialise button
    set f [frame .settingsDlg]
    pack [label $f.label -text {Goal: }] -side left
    pack [entry $f.entry] -side left -fill x -expand true
    button $f.b1 -text Specialise -default active -command {procSpecialise}
    pack $f.b1 -padx 10 -side right
    $f.entry insert 0 {test(a,X)}
}

# ------------------------------------------------------------

proc procAboutEcce {} {
    procShowSourceCode "../README-ECCE"

    image create photo ecce_img -format gif -fil "./icons/ecce_logo.gif"
    .frmSource.text configure -state normal
    .frmSource.text insert 1.0 "\n"
    .frmSource.text image create 1.0 -image ecce_img
    .frmSource.text configure -state disable
}

# ------------------------------------------------------------
# MAIN PROGRAM
# ------------------------------------------------------------
# -------
# procedure initialise everythings
# -------
proc procMainInit {} {
    # initialise GUI
    procInitGUI
    # initialise prolog
    prolog tcltk_initialise
}

procMainInit

