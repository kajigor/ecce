/********************************************************************       PMD:     Find a Preinterpretation, such that threre exits a model     based on that preinterpretaion such that the query is false.  The implementation is based on two principles:    - Tabling, such that each predicate is executed at most once      in the whole computation, but the results are used whenever      the predicate is called.    - CLP: The condition on the preinterpretion such that the query      becomes false are translated to Constraints over finite domains.      After each addition CLP is used to check for the existsence of a      solution  ******************************************************************/:- prolog_flag(compiling, _, fastcode).:- use_module(library(clpfd)).:- use_module(library(terms)).:- use_module(library(assoc)).% :- ensure_loaded(vbn)./* tstart(Vb) with Vb the name of the query   the toplevel-goal for the program. It starts the computation and   gathers results on timings and backtrackpoints, ....  */tstart(Vb):-	time( (start(Vb,1); write(no), nl, true)),	bb_get(3, Nr),	write(final_backtrack(Nr)), nl,	bb_get(4, Nr1),	write(consistency_check(Nr1)), nl,	write(Vb), nl.tstart(Vb, Max):-	time( (start(Vb, Max); write(no), nl, true)),	bb_get(3, Nr),	write(final_backtrack(Nr)), nl,	bb_get(4, Nr1),	write(consistency_check(Nr1)), nl,	write(Vb), nl./* start(Vb) with Vb the name of the query:   initialisation and start up the computation-loop   */start(Vb, Max):-	bb_put(3, 0), % for counting the number of backtrackpoints	              % of the tabling mechanism	bb_put(4, 0), % Counts how often a consistency check is performed	              % by the system	bb_put(6, 0), % Count the  number of assignments in the CLP-system	empty_table(Table), % Table contains information on tabled predicates:	                    % name, arity, solutions, delayed goals.		empty_constraints(Constraints),				% Constraints does not contain the current set				% of constraints, but the finite domain				% variables needed to generate them	clause(Vb, Body),       % collect the query.	solve([goal(false,[], [], Body)], Table, Constraints, sol([],[]), Max)./* solve(Goals, Table, Constraints, Solutions)     Goals: the list of current goals to handle.     Table: The current state ofthe tabling system     Constraints: Information on the FD-variables for generating constraints     Solutions: Remembers the last solution found by a satisfiability check                shows the part of the tree already searched.   */solve([], _Table, _Constraints, _Solution, _Max). % Found a solution! solve(Goals, Table, Constraints, Solution0, Max):-	Goals = [_|_], % for indexing% Uncomment the folowing call fro verbose output%	show_state(Goals, Table, Constraints),% Uncomment following call for a pause after each table-operation%	get0(_), 	select_goal(Goals, Goal, Goals1), % Select one goal	Goal = goal(Lookup, HeadArgs, Equations, Body),	( select_atom(Body, Atom, NewBody) -> % select an atom,	                                      % fail if none exists	    functor(Atom, Name, Arity), 	    Atom =.. [_|Args],	        % lookup handles the call 	    lookup(Table, Table1, Name, Arity, Args, 		   goal(Lookup, HeadArgs, Equations, NewBody), NewGoals),	    Constraints1 = Constraints,	    Solution1 = Solution0	;   	    ( Lookup = false -> % We have a solution for the initial query		add_constraint(not(Equations), Constraints, Constraints1,			       Solution0, Solution1, Max),		NewGoals = [], Table1 = Table	    ;		% We have a solution for a tabled predicate		store_solution(Lookup, HeadArgs, Equations, Table, Table1, 			       Constraints, Constraints1, NewGoals,			       Solution0, Solution1, Max)	    )	),	append(NewGoals, Goals1, Goals2),	solve(Goals2, Table1, Constraints1, Solution1, Max)./* store_solution/10   Lookup: The reference to the table for the predicate, for which           a solution is found.   HeadArgs: The arguments of the solution found   Equations: The conditions onthe unifification for existence of the solution   Table: The current table.   Constraints: Information on the FD-variables for generating constraints   Constraints1: New information on the FD-variables for generating constraints   NewGoals: Goals awoken by the new solution.   Solution0, Solution1: old and new solution found by consistency check   */store_solution(Lookup, HeadArgs, Equations, Table, Table,               Constraints, Constraints1, NewGoals, Solution0, Solution1, Max):-	Lookup = pattern(_Nr, _Name, Solutions, Goals),	Solution = solution(HeadArgs, Equations),	( var(Solutions), Equations = [] ->              /* This is the first solution, with no conditions.		 In case there were conditions we have to make the conditions		 false first */	    Solutions = [Solution|_],	       % Wake up delayed goals	    createExtraGoals2(Goals, Solution, NewGoals),	    Constraints1 = Constraints,	    Solution1 = Solution0	;   	    select_all(Solutions, Sols),	    count(Sols, NrSols), 	    count(HeadArgs, NrArgs),	    power(2, NrArgs, Limit), % For a two-element domain!!!!!!!!!!!!	    ( NrSols = Limit ->		  % The table is full, no additional solutions possible 		add_constraint(presubset_of_solutions(Solution, Sols), 			       Constraints, Constraints1,			       Solution0, Solution1, Max),		NewGoals = []	    ;			(   % First try to get the new solution subsumed 		    add_constraint(presubset_of_solutions(Solution, Sols), 				   Constraints, Constraints1,				   Solution0, Solution1, Max),		    NewGoals = []		;   /* A REAL disjunction */		    bb_get(3, Nr),		    Nr1 is Nr + 1,		    bb_put(3, Nr1),		    write(backtrack(Nr1)), nl,                         % A new solution may not be subsumed byn the old ones		    add_constraint(not_presubset_of_solutions(Solution, Sols), 				   Constraints, Constraints1,				   Solution0, Solution1, Max),		    add_open_end(Solutions, Solution),		        % Wake up delayed goals with the new solution		    createExtraGoals2(Goals, Solution, NewGoals)		)	    )  	).count([], 0).count([_|L], Nr):-	count(L, Nr1),	Nr is Nr1 +1.power(A, N, R):- 	( N =< 0 ->  R = 1;	    N1 is N - 1,	    power(A, N1, R1),	    R is R1 * A	)./* select_all/2 transform an open-ended list in an ended list   */select_all(Var, Sols):- var(Var), !, Sols = [].select_all([Sol|Sols], [Sol|NewSols]):-	select_all(Sols, NewSols)./* empty_table/1 A table is an open ended list   */empty_table(_)./* lookup/7 lookup a predicate and create a new entry if non-existent   In case the predicate is not present yet a new goals can be created   */lookup(Table, Table, Name, Arity, Args, Goal, NewGoals):-	( Table = [entry(Name, Arity, Pattern)| _] ->             % If Table is a variable a new entry will be created.	     % There used to be more that than one call-pattern.	     % Currently there is only one: the most general one.	   catch_pattern(Pattern, 1, Name, Arity, Args, Goal, NewGoals)	;   	    Table = [_|Table1],	    lookup(Table1, _, Name, Arity, Args, Goal, NewGoals)	)./* catch_pattern/7: Find the matching call-patterns if it exists.   Currenly there is only one call-pattern: the most general one.   */catch_pattern(Pattern, Nr, Name, Arity, Args, Goal, NewGoals):-        ( var(Pattern) ->	      /* The predicate was not tabled yet.		 The goal must be delayed */	    Goals = [delayed_goal(Args, Goal)|_],	    Pattern = pattern(Nr, Name,  _Solutions, Goals),	       /* The definitions of the predicates are added to the goals */	    findall(G, find_generators(Name, Arity, G), TempGoals),	       % Create goals in the fromat in the system and	       % add a reference to the table (variable Pattern)	       % return them in the variable NewGoals	    fill_in_pattern(TempGoals, Pattern, NewGoals)        ;   	    Pattern = pattern(_, _Name,  Solutions, Goals),                    % Add the goal to the delayed goals	    add_open_end(Goals, delayed_goal(Args, Goal)),	            % Create new goals with the current solutions and	            % return them in the variable NewGoals	    createExtraGoals(Solutions, delayed_goal(Args, Goal), NewGoals)	)./* createExtraGoals/3 : Given an open ended list Solutions and a Goal,   create a list of new goals, for each solution one goal.   The goal contains calling parameters, which have to be unified with   the solution */createExtraGoals(Solutions, Goal, NewGoals):-	( var(Solutions) -> NewGoals = []	;   	    Solutions = [Solution|Solutions1],	      /* Create a new goal given a delayed Goal and a Solution.		 Unify the calling arguments with the solution */	    new_goal_with_solution(Goal, Solution, NewGoal),	    NewGoals = [NewGoal|NewGoals1],	    createExtraGoals(Solutions1, Goal, NewGoals1)	)./* createExtraGoals/3 : Given an open ended list of delayed Goals and   a Solution, create a list of new goals, for each delayed goal one goal.   The goals contain calling parameters, which have to be unified with   the solution */createExtraGoals2(Goals, Solution, NewGoals):-	( var(Goals) -> NewGoals = []	;   	    Goals = [Goal|Goals1],	    new_goal_with_solution(Goal, Solution, NewGoal),	    NewGoals = [NewGoal|NewGoals1],	    createExtraGoals2(Goals1, Solution, NewGoals1)	)./* new_goal_with_solution/2 Use a solution and a delayed goal to create   a new Goal. The calling argument have to unified with the arguments   of the solution. */new_goal_with_solution(Goal, Solution, Result):-	Goal = delayed_goal(CallingArgs, 			    goal(Lookup, HeadArgs, Equations, Body)),	     /* create a fresh copy! */	copy_term(temp(CallingArgs, HeadArgs, Equations, Body), 		  temp(NewCallingArgs, NewHeadArgs, NewEquations, NewBody)),	     /* create a fresh copy! */	copy_term(Solution, NewSolution),	NewSolution = solution(ArgsSol, EqSol),              /* Perform unification btween the solution and the arguments of		 the call. This could results in a list of new		 equations EqArgs */	handleArguments(NewCallingArgs, ArgsSol, EqArgs),	append(EqArgs, EqSol, ResEq),	append(ResEq, NewEquations, NewEq),	Result = goal(Lookup, NewHeadArgs, NewEq, NewBody)./* handleArguments/3 Unify the elements in the two list pairwise.   Only when both are not ground and not identical createan equation */handleArguments([], [], []).handleArguments([Arg|Args], [ArgSol|ArgsSol], EqArgs):-	( var(Arg) ->	    Arg = ArgSol, 	    handleArguments(Args, ArgsSol, EqArgs)	;   	    ( var(ArgSol) -> 		Arg = ArgSol,		handleArguments(Args, ArgsSol, EqArgs)	    ;			( Arg == ArgSol ->  handleArguments(Args, ArgsSol, EqArgs)		;   EqArgs = [Arg = ArgSol|EqArgs1],		    handleArguments(Args, ArgsSol, EqArgs1)		)	    )	).add_open_end(List, Element):-	var(List) -> List = [Element|_]; 	List = [_|List1],	add_open_end(List1, Element)./* select_goal/3 : selection stategy for selecting a goal from a list of   goals.   - First select the goals that have false in the head.     This leads, or to a delayed goal, or a new solution for the query.     never to a backtrackpoint   - Second select a goal with an non-empty body.     Also never creates a backtrack-point   - Third: select the goal with as few functors in it as possible.     If handeling them fails we'll be happy top avoid the complicated ones.*/select_goal(Goals0, Goal, Goals1):-	Goals0 = [_|_],	( false_head(Goals0, Goal, Goals1) ->	    true;	    ( non_empty_body(Goals0, Goal, Goals1) ->	        true;		smallest_goal(Goals0, Goal, Goals1)	    )	)./* smallest_goal/3: Choose the smallest goal in terms of number of functors   in the list of goals.*/smallest_goal([Goal|Goals], Goal1, Goals1):-	Goal = goal(Lookup, Args, Equations, _Body),	size_goal(Args, 0, Size0),	size_equations(Equations, Size0, Size1),	(Lookup = false -> Size = Size1;	    arg(3, Lookup, Solutions),	      /* Take into account the solutions already found for this		 goal. */	    size_solutions(Solutions, Size1, Size)	),%	write(size(Args, Equations, Size)), nl,	Current = current(Goal, Goals1, Goals, Goals2),	smallest_goal(Goals, Goal1, Goals2, Current, Size).%	write(succeed), nl./* smallest_goal/5: recursive variant that compares with the best solution   so far. */smallest_goal([], Goal, [], current(Goal, Goals, Goals, _RGoals), _Size).smallest_goal([Goal|Goals], Goal1, Goals1, Current, Size):-	Goal = goal(Lookup, Args, Equations, _Body),	(   size_goal(Args, 0, NewSize0, Size),	    size_equations(Equations, NewSize0, NewSize1, Size),	    (Lookup = false -> NewSize = NewSize1;		arg(3, Lookup, Solutions),		size_solutions(Solutions, NewSize1, NewSize, Size)	    ) ->%	    write(size(Args, Equations, NewSize)), nl, 	    Current = current(OldGoal, [OldGoal|RGoals], _OldGoals, RGoals),	    NewCurrent = current(Goal, Goals1, Goals, Goals2),	    smallest_goal(Goals, Goal1, Goals2, NewCurrent, NewSize)        ;   	    Goals1 = [Goal|Goals2],	    smallest_goal(Goals, Goal1, Goals2, Current, Size)        ).size_goal([], Size, Size).size_goal([Arg|Args], OldSize, Size):-	size_goal_arg(Arg, OldSize, NewSize),	size_goal(Args, NewSize, Size).size_equations([], Size, Size).size_equations([L=R|Eqs], Size0, Size1):-	size_goal_arg(L, Size0, Size2),	size_goal_arg(R, Size2, Size3),	size_goal(Eqs, Size3, Size1).size_solutions(Solutions, Size0, Size1):-	var(Solutions), !, Size1 = Size0.size_solutions([Solution|_Solutions], Size0, Size1):-	var(Solution), !, Size1 = Size0.size_solutions([Solution|Solutions], Size0, Size1):-	Solution = solution(Args, Equations),	size_goal(Args, 0, Size2),	size_equations(Equations, Size2, Size3),	size_solutions(Solutions, Size3, Size4),	Size1 is Size0 + 10 * Size4 + 10.	size_goal_arg(Var, Size0, Size1):- var(Var), !, Size1 = Size0.size_goal_arg(Functor, Size0, Size1):- 	functor(Functor, _Name, Arity),	Size2 is Size0 + Arity + 1,	Functor =..  [_|Args],	size_goal(Args, Size2, Size1).size_goal([], Size, Size, _OldSize).size_goal([Arg|Args], Size0, Size, OldSize):-	size_goal_arg(Arg, Size0, Size1, OldSize),	size_goal(Args, Size1, Size, OldSize).size_equations([], Size, Size, _OldSize).size_equations([L=R|Eqs], Size0, Size1, OldSize):-	size_goal_arg(L, Size0, Size2, OldSize),	size_goal_arg(R, Size2, Size3, OldSize),	size_goal(Eqs, Size3, Size1, OldSize).size_solutions(Solutions, Size0, Size1, _OldSize):-	var(Solutions), !, Size1 = Size0.size_solutions([Solution|_Solutions], Size0, Size1, _OldSize):-	var(Solution), !, Size1 = Size0.size_solutions([Solution|Solutions], Size0, Size1, OldSize):-	Solution = solution(Args, Equations),	size_goal(Args, 0, Size2),	size_equations(Equations, Size2, Size3),	size_solutions(Solutions, Size3, Size4, OldSize),	Size1 is Size0 + 10 *Size4 + 10,	Size1 < OldSize.size_goal_arg(Var, Size0, Size1, _OldSize):- var(Var), !, Size1 = Size0.size_goal_arg(Functor, Size0, Size1, OldSize):- 	functor(Functor, _Name, Arity),	Size2 is Size0 + Arity + 1,	Size2 < OldSize,	Functor =..  [_|Args],	size_goal(Args, Size2, Size1, OldSize).tail_goal([Goal1|Goals1], Goal2, Goals2):-	( Goals1 = [] ->             Goal2 = Goal1, Goals2 = [];	    Goals2 = [Goal1|Goals3],	    tail_goal(Goals1, Goal2, Goals3)	).non_empty_body([Goal|Goals], Goal1, Goals1):-	Goal = goal(_Lookup, _HeadArgs, _Equations, Body),         ( select_atom(Body, _, _) -> 	    Goal1 = Goal, Goals1 = Goals        ;   	    Goals1 = [Goal|Goals2],	    non_empty_body(Goals, Goal1, Goals2)	).false_head([Goal|Goals], Goal1, Goals1):-	Goal = goal(Lookup, _HeadArgs, _Equations, _Body),         ( Lookup = false ->  	    Goal1 = Goal, Goals1 = Goals        ;   	    Goals1 = [Goal|Goals2],	    false_head(Goals, Goal1, Goals2)	).select_atom((Atom, Atoms), Atom, Atoms):- !.select_atom(Atom, Atom, true) :- \+ (Atom = true).fill_in_pattern([], _Pattern, []).fill_in_pattern([goal(Args, Body)|Goals], Pattern,                 [goal(Pattern, Args, [], Body)|NewGoals]):-        fill_in_pattern(Goals, Pattern, NewGoals).find_generators(Name, Arity, Goal):-	functor(Head, Name, Arity),	clause(Head, Body),	Head =.. [_|NewArgs],	Goal = goal(NewArgs, Body).append([], C, C).append([X|A], B, [X|C]):-	append(A, B, C)./* add_constraint/5: Add a constraint on the finite domain variables of the   system. If some finite domain variables do not exist yet, create them.   After adding the constraint satisfiability is checked   C: The new condition over the preiniterpretation   Info: The already existing finite domain variables   New:  The finite domain variables after adding the constraint.   Solution0: The old solution, after the previous check.   Solution1: The new solution after the new check.*/   add_constraint(C, Info, New, Solution0, Solution1, Max):-	write(adding_constraint(C, Max)), nl,	   /* Make things ground where necesary */	preprocess(C, NewC, Max),	Info = info(_E, F),	   /* Create constraint over the finite domain variables */        simplify_constraints(NewC, Info, New, Max),	New = info(_E1, F1),	(   empty_assoc(F),	    min_assoc(F1, _Key, i(FDVar, _)) ->	       % If the first variable just has been created, then fix it to 0	    FDVar #= 0        ;   	    true        ),	bb_get(4, Nr),	Nr1 is Nr +1,	bb_put(4, Nr1),	write(checking_solvable(Nr1)), nl,	Solution0 =..[_,SolVars, SolValues],	newSolVars(SolVars, F1, SolVars1),	   % Check solvability without binding variables	\+ \+ ( satisfied(SolValues, SolVars1, Values), bb_put(2, Values)),	bb_get(2, Vs), nl,	write('current solution : '), nl,	show_vars(SolVars1),	write(Vs), nl,	Solution1 = sol(SolVars1, Vs),	bb_get(6, Ass),	write('checked solvable'(Ass)), nl./* newSolVars/3: Find  all variables to be enumerated */newSolVars([], F, SolVars1):-	assoc_to_list(F, SolVars1).newSolVars([First|Vars], F, [First|NewVars]):-	First = Key-_Var,	del_assoc(Key, F, _Var1, F1),	newSolVars(Vars, F1, NewVars)./* preprocess/2L make things ground where necesary */preprocess(C, NewC, Max):- C = not(Eqs), 	term_variables(Eqs, Vars),        findall(C, gene(Vars, Max), NewC).preprocess(C, NewC, Max):- C = presubset_of_solutions(Sol, Sols), 	findall(OSol, 		(   real_member(OSol, Sols),                     term_variables_own(OSol, OVars),                    gene(OVars,Max) ), OSols),        TempC = presubset_of_solutions(Sol, OSols),        term_variables(Sol, Vars),        findall(TempC, gene(Vars, Max), NewC).preprocess(C, NewC, Max):- C = not_presubset_of_solutions(Sol, Sols), 	findall(OSol, 		(   real_member(OSol, Sols),                     term_variables_own(OSol, OVars),                    gene(OVars, Max) ), OSols),        term_variables(Sol, Vars),        findall(Sol, gene(Vars, Max), NSols),        NewC = not_presubset_of_solutions(NSols, OSols)./* term_variables_own/2 Find all free variables which are not in the argument   positions.   */term_variables_own(OSol, OVars):-	OSol = solution(OArgs, OEqs),	nonvar_args(OArgs, Rem),	term_variables([Rem|OEqs], OVars).nonvar_args([], []).nonvar_args([Arg|Args], NArgs):-	( var(Arg) -> nonvar_args(Args, NArgs);	    NArgs = [Arg| NArgs1],	    nonvar_args(Args, NArgs1)	)./* gene/1: generate a ground version over the domain of the preiniterpretation   */gene(Vars, Max):-	findall(Val, (translate(Val, N), N =< Max), Vals),	genevl(Vars, Vals).genevl([], _VL).genevl([V|Vs], VL):-	real_member(V, VL),	genevl(Vs, VL)./* simplify_constraints/3: Generate constraint over the finite domain   variables */simplify_constraints([], Info, Info, _Max):- !.simplify_constraints([A|B], Info0, Info1, Max):- !,	simplify_constraints(A, Info0, Info2, Max),        simplify_constraints(B, Info2, Info1, Max).simplify_constraints(not(Eqs0), Info0, Info1, Max):-	eqs_to_bools(Eqs0, Bools, Info0, Info1, Max),        sum_my(Bools, Sum, N),	call(Sum #=< N).simplify_constraints(presubset_of_solutions(Sol0, Sols0), Info0, Info1, Max):-	Sol0 = solution(Args, Eqs),	( Eqs = [] ->	    list_of_mappings(Sols0, Args, Mappings, Info0, Info1, Max),	    sum_my(Mappings, MappingsSum, _),	    call(MappingsSum #>= 1)        ;               eqs_to_bools(Eqs, Bools, Info0, Info2, Max),            sum_my(Bools, Sum, N),	    N1 is N +1,	    ( N1 = 1 ->                Sum = Beqs            ;	                Beqs in 0 ..1,	        call(Beqs #<=> Sum #= N1)	    ),	    list_of_mappings(Sols0, Args, Mappings, Info2, Info1, Max),	    sum_my(Mappings, MappingsSum, _),	    call(MappingsSum #>= Beqs)        ).simplify_constraints(not_presubset_of_solutions(NSols, OSols), Info0, Info1, Max):-	not_subsumed_vars(NSols, OSols, NotSubVars, Info0, Info1, Max),	sum_my(NotSubVars, Sum, _N),	call(Sum #> 0).not_subsumed_vars([], _OSols, [], Info, Info, _Max).not_subsumed_vars([NSol|NSols], OSols, [NotSubVar|NotSubVars], Info0, Info1, Max):-	NSol = solution(Args, Eqs),	NotSubVar in 0..1,	( Eqs = [] ->	    list_of_mappings(OSols, Args, Mappings, Info0, Info3, Max),	    sum_my(Mappings, MappingsSum, _),	    call(NotSubVar #<=> MappingsSum #= 0)        ;               eqs_to_bools(Eqs, Bools, Info0, Info2, Max),            sum_my(Bools, Sum, N),	    N1 is N +1,	    ( N1 = 1 ->                Sum = Beqs            ;	                Beqs in 0..1,	        call(Beqs #<=> Sum #= N1)	    ),	    list_of_mappings(OSols, Args, Mappings, Info2, Info3, Max),	    sum_my(Mappings, MappingsSum, _),	    call(NotSubVar #<=> MappingsSum #< Beqs)        ),	not_subsumed_vars(NSols, OSols, NotSubVars, Info3, Info1, Max).	eqs_to_bools([], [], Info, Info, _Max).eqs_to_bools([L=R|Eqs], [Bool|Bools], Info0, Info1, Max):-	getBool(L, R, Bool, Info0, Info2, Max),	eqs_to_bools(Eqs, Bools, Info2, Info1, Max).sharing_bools([], _, Bools, Bools, Info, Info, _Max).sharing_bools([E1|Expr], E2, [Bool|Bools1], Bools2, Info0, Info1, Max):-	getBool(E2, E1, Bool, Info0, Info2, Max),	sharing_bools(Expr, E2, Bools1, Bools2, Info2, Info1, Max).args_to_bools([], [], [], _Sharing, Info, Info, _Max).args_to_bools([L|OArgs], [R|Args], Bools1, Sharing, Info0, Info1, Max):-	( var(L) ->	    lookup_expr_sharing(Sharing, L, R, NewSharing, Exprs),	    sharing_bools(Exprs, R, Bools1, Bools2, Info0, Info2, Max),	    args_to_bools(OArgs, Args, Bools2, NewSharing, Info2, Info1, Max)	;   	    Bools1 = [Bool|Bools],	    getBool(L, R, Bool, Info0, Info2, Max),	    args_to_bools(OArgs, Args, Bools, Sharing, Info2, Info1, Max)	).list_of_mappings([], _Args, [], Info, Info, _Max).list_of_mappings([solution(OArgs, OEqs)|Solutions], Args,                  [Mapping|Mappings], Info0, Info1, Max):-	args_to_bools(OArgs, Args, ABools, [], Info0, Info2, Max),	sum_my(ABools, ASum, AN),	( OEqs = [] ->	    AN1 is AN + 1,	    ( AN1 = 1 -> 		ASum = Mapping	    ;			Mapping = MappingV,		MappingV in 0..1,		call(MappingV #<=> ASum #= AN1)	    ), Info3 = Info2	;   	    eqs_to_bools(OEqs, OBools, Info2, Info3, Max),	    sum_my(OBools, OeqsSum, N),	    N1 is N + 1,	    OEqsVar in 0..1,	    call(OEqsVar #<=> OeqsSum #= N1),	    AN2 is AN + 2,	    Mapping = MappingV,	    MappingV in 0 ..1,	    call(MappingV #<=> ASum + OEqsVar #= AN2)	),	list_of_mappings(Solutions, Args, Mappings, Info3, Info1, Max). lookup_expr_sharing([], Var, Arg, [sharing(Var, [Arg])], []).lookup_expr_sharing([Sharing0|Sharing], Var, Arg, NewSharing, R):-	Sharing0 = sharing(Var1, Exprs),	( Var1 == Var ->	    R = Exprs,	    NewSharing = [sharing(Var1, [Arg|Exprs])|Sharing]        ;   	    NewSharing = [ Sharing0|Sharing1],	    lookup_expr_sharing(Sharing, Var, Arg, Sharing1, R)        ).real_member(M, [M|_]).real_member(M, [_|L]):-	real_member(M, L).member(M, [M|_]):- !.member(M, [_|L]):-	member(M, L).bound(Var):- var(Var), !, fail.bound(Ground):-translate(Ground, _Nr).bbound(Ground):- translate(Ground, _Nr)./* last_level/1 Is the agrgument a functor with it's arguments domain elements?   */last_level(Functor):- nonvar(Functor),	Functor =.. [_|Args],	boundList(Args).boundList([]).boundList([Arg|Args]):-	bound(Arg),	boundList(Args).as:-	bb_get(6, Nr),	Nr1 is Nr +1,	bb_put(6, Nr1)./* satisfied/3: enumerate to prove there exists a solution. Start the search   from the ols solution in the first argument*/satisfied([], Vars, NewV):-	satisfied(Vars, NewV).satisfied([Value|Values], [Info|Vars], [NewV|NewVs]):-	Info = _Expr-i(Var,_Bools),	(   as,	    Var #= Value, /* try old solution */	    write(a), NewV = Value,	    satisfied(Values, Vars, NewVs)	;    /* backtrack, old solution does not work */	    Var #> Value, write(n), nl,	    satisfied([Info|Vars],[NewV|NewVs])	).satisfied([], []).satisfied([_Expr-i(Var, _Bool)|Vars], [NewV|NewVs]):-%	write(x), nl,	fd_set(Var, Set),	fdset_member(NewV, Set),	as,	Var #= NewV,%	write(n),%	portray(p(Vars, NewVs)), nl,	satisfied(Vars, NewVs).translate(aaa, 0).translate(bbb, 1).translate(ccc, 2).translate(ddd, 3).translate(eee, 4).translate(fff, 5).translate(ggg, 6).translate(hhh, 7).translate(iii, 8).translate(jjj, 9)./* empty_constraints/1: The variables already generated are kept in an   assoc-list. Two parts. The first part containts the bare functors.   The second part the complicated terms. I forgot why these two   parts are not merged. Each entry in the assoc-list containt the finite   domain variable connected to the term. Next to that finite domain   variables thers is again an assoc list. This assoc-list contains   all equality boolean variables connected to that finite domain variables.   The entries are based on the expression compared with */   empty_constraints(info(Assoc1, Assoc2)):- 	empty_assoc(Assoc1),	empty_assoc(Assoc2)./* The following predicates handle the retrieval of already existing   finite domain variables. If they do not exist they are created.   If variables are created for compound terms, also constraints   have to be generated for connecting them with the basic ones   */getBoolSimple(Expr1, Expr2, BoolE, Info0, Info1, Max):-	( Expr1 = Expr2 -> BoolE = 1, Info1 = Info0;	    ( bbound(Expr1) -> 		( bbound(Expr2) -> 		    BoolE = 0,		    Info1 = Info0		;   getBool_expr_bbound(Expr2, Expr1, BoolE, Info0, Info1, Max)		)	    ;		bbound(Expr2),		getBool_expr_bbound(Expr1, Expr2, BoolE, Info0, Info1, Max)	    )	).getBool(Expr1, Expr2, BoolE, Info0, Info1, Max):-	( getBoolSimple(Expr1, Expr2, BoolE, Info0, Info1, Max) -> true	;	    BoolE = Bool,	    getExprInfo(Expr1, Info0, Value, Info2, Max),	    Value = i(FDVar1, Bools1),	    ( get_assoc(Expr2, Bools1, Bool) ->	Info1 = Info2	    ;			getExprInfo(Expr2, Info2, i(FDVar2, Bools2), Info3, Max),		( get_assoc(Expr1, Bools2, Bool) ->  Info1 = Info3		;		    get_assoc_my(Expr1, Info3, i(_, Bools1a)),		    Bool in 0..1,		    Bool #<=> FDVar1 #= FDVar2,		    put_assoc(Expr2, Bools1a, Bool, Bools11),		    put_assoc_my(Expr1, Info3,i(FDVar1,Bools11), Info1a),		    put_assoc(Expr1, Bools2, Bool, Bools22),		    put_assoc_my(Expr2, Info1a, i(FDVar2, Bools22), Info1)		)	    )	).getBool_expr_bbound(Expr1, Expr2, BoolE, Info0, Info1, Max):-	BoolE = Bool,	getExprInfo(Expr1, Info0, Value, Info2, Max),	Value = i(FDVar1, Bools1),	( get_assoc(Expr2, Bools1, Bool) ->	    Info1 = Info0	;	    Bool in 0..1,	    translate(Expr2, Va),	    Bool #<=> FDVar1 #= Va,	    put_assoc(Expr2, Bools1, Bool, Bools11),	    put_assoc_my(Expr1, Info2, i(FDVar1, Bools11), Info1)	).getFDVar(Expr, Info0, V, Info1, Max):-	( translate(Expr, Value) -> V = Value         ;   V = FDVar,	    getExprInfo(Expr, Info0, i(FDVar, _Bools), Info1, Max)	).getExprInfo(Expr, Info0, ExprInfo, Info1, Max):-	( get_assoc_my(Expr, Info0, ExprInfo) ->            Info1 = Info0        ;   	    FDVar in 0..Max,	    empty_assoc(Bools),	    ExprInfo =  i(FDVar, Bools),	    Info0 = info(ExprInfo0, FunctorInfo0),	    ( last_level(Expr) ->		put_assoc(Expr, FunctorInfo0, ExprInfo, FunctorInfo1),		Info1 = info(ExprInfo0, FunctorInfo1)	    ;		        put_assoc(Expr, ExprInfo0, ExprInfo, ExprInfo2),		Info2 = info(ExprInfo2, FunctorInfo0),		Expr =.. [Name|Args],		collectSubArgs(Args, NewArgs, Info2, Info3, ArgVars,Exprs,Max),		Functor =.. [Name|NewArgs],		findall(inst(Functor, ArgVars), gene(ArgVars, Max), Instances),		connect_vars(Instances, Exprs, Info3, Info1, Expr, Max) 	    )	).collectSubArgs([], [], Info, Info, [], [], _Max).collectSubArgs([Arg|Args], [NArg|NArgs], Info0, Info1, ArgVars, Exprs, Max):-	( bbound(Arg) ->	    NArg = Arg,	    collectSubArgs(Args, NArgs, Info0, Info1, ArgVars, Exprs, Max)	;   	    getExprInfo(Arg, Info0, _ExprInfo, Info2, Max),	    ArgVars = [NArg|ArgVars1],	    Exprs = [Arg|Exprs1],	    collectSubArgs(Args, NArgs, Info2, Info1, ArgVars1, Exprs1, Max)	).connect_vars([], _FDVars, Info, Info, _Expr, _Max).connect_vars([inst(Functor, ArgVars)| Instances], Exprs, Info0, Info1, Expr, Max):-	collect_booleans(Exprs, ArgVars, Booleans,  Info0, Info2, Max),	sum_my(Booleans, Sum, N),	Info2 = info(ExprVars2, _FunctorVars2),	get_assoc(Expr, ExprVars2, i(FDVar, Bools2)),	( get_assoc(Functor, Bools2, Bool) -> Info3=Info2;	    getExprInfo(Functor, Info2, i(FDVarFunctor, BoolsFunctor), Info4, Max),	    Bool in 0..1,	    Bool #<=> FDVar #= FDVarFunctor,	    put_assoc(Functor, Bools2, Bool, Bools3),	    put_assoc_my(Expr, Info4, i(FDVar, Bools3), Info5),	    put_assoc(Expr, BoolsFunctor, Bool, BoolsFunctor2),	    put_assoc_my(Functor, Info5, i(FDVarFunctor,BoolsFunctor2), Info3)	),        call(Sum #=< N + Bool),	connect_vars(Instances, Exprs, Info3, Info1, Expr, Max).collect_booleans([], [], [], Info, Info, _Max).collect_booleans([Expr|Exprs], [Arg|Args], [BoolE|Booleans], Info0, Info1, Max):-	getBool_expr_bbound(Expr, Arg, BoolE, Info0, Info2, Max),	collect_booleans(Exprs, Args, Booleans, Info2, Info1, Max).sum_my([], 0, -1).sum_my([Bool|Bools], Sum, N):-	( Bools = [] ->	    Sum = Bool, N = 0	;   	    sum_my(Bools, Sum1, N1),	    Sum = Bool + Sum1,	    N is N1 + 1	).get_assoc_my(Term, info(ExprInfo, FunctorInfo), Value):-	( last_level(Term) ->	    get_assoc(Term, FunctorInfo, Value)	;   	    get_assoc(Term, ExprInfo, Value)	).put_assoc_my(Term, info(ExprInfo0, FunctorInfo0), Value, 	     info(ExprInfo1, FunctorInfo1)):-	( last_level(Term) ->	    ExprInfo1 = ExprInfo0,	    put_assoc(Term, FunctorInfo0, Value, FunctorInfo1)	;   	    FunctorInfo1 = FunctorInfo0,	    put_assoc(Term, ExprInfo0, Value, ExprInfo1)	). /* output predicates, ... */portray(X):- write(X).value_finite_domain_var(V, List):-	fd_dom(V, Range),	( Range = 0..1 -> List = [0,1]	;	    ( Range = {X} ->  List = [X]	    ;		write('strange domain'), nl , halt	    )	).time(X):-	statistics(runtime, _),	user:X,	statistics(runtime, [_, A]),	write(A), nl.show_vars([]):- nl.show_vars([Expr-i(Var, _Bool)|Vars]):-	portray(e(Expr, Var)), write(' '),	show_vars(Vars).show_state(Goals, Table, Constraints):-	write('-----------------------------------------------------------'), nl,	write('goals: '), nl,	show_goals(Goals),	write('table: '), nl, 	show_table(Table),	write('constraints: '), nl,	show_store(Constraints),	write('-----------------------------------------------------------'), nl.show_store(info(_A,B)):-				%       map_assoc(t, A), nl,	map_assoc(t, B).t(X):- X = i(Value, _Bools),	portray(Value), write('  '), nl.				% map_assoc(n, Bools), nl.n(X):- portray(X), write('  ').ind(N):-	( N = 0 -> true;	    write(' '),	    N1 is N -1,	    ind(N1)	).show_goals([]).show_goals([Goal|Goals]):-	ind(7),	Goal = goal(Lookup, HeadArgs, Equations, Body),	( Lookup = false -> 	    write(false)	;   	    arg(2, Lookup, Name),	    P =.. [Name|HeadArgs],	    write(P)	),	write((:-)),		write(Equations),		write(Body), nl,		show_goals(Goals).show_table(Free):- var(Free), !.show_table([entry(Name, Arity, Pattern)|Table]):-	ind(7), write(Name/Arity), nl,	write_pattern(Pattern),	show_table(Table).write_pattern(pattern(_Nr, _Name, Solutions, _Goals)):-	ind(14), write('solutions: '), nl, write_solutions(Solutions),        ind(14), write('delayed goals: '), nl, write_goals(Goals).write_goals(V):- var(V), !.write_goals([X|Y]):-	ind(21),	X = delayed_goal(CallingArgs, goal(Lookup, HeadArgs, Equations, Body)),	write('args: '), write(CallingArgs), write('  '),	( Lookup = false ->	    write('head: '), write(false)  	;   	    arg(2, Lookup, Name),	    Head =.. [Name| HeadArgs],	    write('head: '), write(Head)	),	write(' equations: '), write(Equations), 	write(' body: '), write(Body),	nl, 	write_goals(Y).write_solutions(V):- var(V), !.write_solutions([X|Y]):- ind(21), write(X), nl,	write_solutions(Y).show_constraints(constraint_store(Cs, Ds)):-	show_constraints(Cs),	write(Ds), nl.show_constraints([]):- nl.show_constraints([C|Cs]):- 	ind(7), write(C), nl,	show_constraints(Cs).