depth( true, 0 ).depth( (_g1,_gs), _depth ) :-    depth( _g1, _depth_g1 ),    depth( _gs, _depth_gs ),    max( _depth_g1, _depth_gs, _depth ).depth( _goal, s(_depth) ) :-    prog_clause( _goal, _body ),    depth( _body, _depth ).max( _num, 0, _num ).max( 0, s(_num), s(_num) ).max( s(_x), s(_y), s(_max) ) :-    max( _x, _y, _max ).prog_clause( member( _X, _Xs ), append( _, [_X|_], _Xs ) ).prog_clause( append( [], _L, _L ), true ).prog_clause( append( [_X|_L1], _L2, [_X|_L3] ), append( _L1, _L2, _L3 ) ).  /*  unfold_prog_clause(T) :- true.unfold_max(T) :- (not(member(depth(d,_,_),T)) ;	not(member(depth(_,d,_),T)) ; not(member(depth(_,_,d),T)) ).	unfold_depth(T) :- not(member(depth(_,d),T)).*//* The partial deduction query :- depth(member(X,[a,b,c,m,d,e,m,f,g,m,i,j]),Depth).The run-time queries :- depth(member(i,[a,b,c,m,d,e,m,f,g,m,i,j]),Depth).*/test1(X,L,D) :- depth(member(X,L),D).test2(X,D) :- depth(member(X,[a,b,c,m,d,e,m,f,g,m,i,j]),D)./*| ?- time(bta_depth([],_),T). T = 0.5790; no| ?- gu.Info = depth(depth(d,d)), clause #: 3  PP = 2Call = prog_clause([depth(d,d),depth(d,s),depth(s,d),depth(s,s)])  yes| ?- gm.Info = max(depth(d,d,d)), clause #: 3  PP = 4  Call = max([depth(d,d,d),depth(d,d,s),depth(d,s,d),depth(d,s,s),depth(s,d,d),depth(s,d,s),depth(s,s,d),depth(s,s,s)]) Info = depth(depth(d,d)), clause #: 3  PP = 3  Call = depth([depth(d,d),depth(d,s),depth(s,d),depth(s,s)]) Info = depth(depth(d,d)), clause #: 2  PP = 4  Call = max([depth(d,d,d),depth(d,d,s),depth(d,s,d),depth(d,s,s),depth(s,d,d),depth(s,d,s),depth(s,s,d),depth(s,s,s)]) Info = depth(depth(d,d)), clause #: 2  PP = 3  Call = depth([depth(d,d),depth(d,s),depth(s,d),depth(s,s)]) Info = depth(depth(d,d)), clause #: 2  PP = 2  Call = depth([depth(d,d),depth(d,s),depth(s,d),depth(s,s)]) */