ORIGINAL PROGRAM
================

foo(X,Y,Z,W) :- 
  app(X,Y,XY), len(XY,L),
  snd(Z,Zsnd), fst((L,Zsnd),W).

len([],zero).
len([_|R],succ(RL)) :- len(R,RL).

app([],Y,Y).
app([H|R],Y,[H|RY]) :- app(R,Y,RY).

fst((X,_),X).
snd((_,Y),Y).

==================================

With classical (atomic) PD, single step unfolding rule we get:

/* Specialised Predicates: 
foo__1(A,B,C) :- foo([],A,B,C).
app__2(A,B) :- app([],A,B).
len__3(A,B) :- len(A,B).
snd__4(A,B) :- snd(A,B).
fst__5(A,B,C) :- fst(','(A,B),C).
*/

foo([],A,B,C) :- 
    foo__1(A,B,C).

/* foo__1(A,B,C) --> [foo([],A,B,C)] */
foo__1(A,B,C) :- 
    app__2(A,D), 
    len__3(D,E), 
    snd__4(B,F), 
    fst__5(E,F,C).

/* app__2(A,B) --> [app([],A,B)] */
app__2(A,A).

/* len__3(A,B) --> [len(A,B)] */
len__3([],zero).
len__3([A|B],succ(C)) :- 
    len__3(B,C).

/* snd__4(A,B) --> [snd(A,B)] */
snd__4(','(A,B),B).

/* fst__5(A,B,C) --> [fst((A,B),C)] */
fst__5(A,B,A).

The only thing that has been removed is the first clause of append:
not very satisfactory

Reason: information propagation in standard PD is not very good 
     + with single step unfolding we basically get no propagation among different
       calls in the body of a clause. This is problematic for the "nested function
       calls", see adapted foo below
       We do get propagation from head of a clause to each individual call in the
        body, but that is not enough here; except for append.

If we change foo into:        
foo(X,Y,Z,W) :- X=X2,
  app(X2,Y,XY), len(XY,L),
  snd(Z,Zsnd), fst((L,Zsnd),W).
then we already lose slicing for app:

foo(X,Y,Z,W) :- 
  app(X,Y,XY), len(XY,L),
  snd(Z,Zsnd), fst((L,Zsnd),W).
  
eq(X,X).

as we get:
/* foo__1(A,B,C) --> [foo([],A,B,C)] */
foo__1(A,B,C) :- 
    eq__2(D), 
    app__3(D,A,E), 
    len__4(E,F), 
    snd__5(B,G), 
    fst__6(F,G,C).

/* eq__2(A) --> [eq([],A)] */
eq__2([]).

/* app__3(A,B,C) --> [app(A,B,C)] */
app__3([],A,A).
app__3([A|B],C,[A|D]) :- 
    app__3(B,C,D).
    
      
==================================

One way to overcome this: move to conjunctive PD. 
In general this will allow the same predicate to appear in many conjunctions: so there
is a problem of extracting a single slice for such predicates. But I think it can be
done.


We now get (I had to turn off most post-processing + also the most specific resolution
 steps; the only thing I kept is the redundant argument filtering):

/* Specialised program generated by Ecce 1.1 *//* PD Goal: foo([],A,B,C) */
/* Parameters: Abs:m InstCheck:v Msv:n NgSlv:g Part:c Prun:n Sel:c Whstl:m
 Raf:yesFar:yes Dce:no Poly:n Dpu:no ParAbs:yes Msvp:no Rrc:no */
/* Transformation time: 50 ms */
/* Unfolding time: 20 ms */
/* Post-Processing time: 0 ms */

/* Specialised Predicates: 
foo__1(A,B,C) :- foo([],A,B,C).
eq_conj__2(A,B,C) :- eq([],D1), app(D1,A,E1), len(E1,F1), snd(B,G1), fst(','(F1,G1),C).
app_conj__3(A,B,C) :- app([],A,D1), len(D1,E1), snd(B,F1), fst(','(E1,F1),C).
len_conj__4(A,B,C,D,E) :- len(A,B), snd(C,F1), fst(','(D,F1),E).
snd_conj__5(A,B,C) :- snd(A,D1), fst(','(B,D1),C).
fst__6(A,B) :- fst(','(A,C1),B).
*/

foo([],A,B,C) :- 
    foo__1(A,B,C).
foo__1(A,B,C) :- 
    eq_conj__2(A,B,C).
eq_conj__2(A,B,C) :- 
    app_conj__3(A,B,C).
app_conj__3(A,B,C) :- 
    len_conj__4(A,D,B,D,C).
len_conj__4([],zero,A,B,C) :- 
    snd_conj__5(A,B,C).
len_conj__4([A|B],succ(C),D,E,F) :- 
    len_conj__4(B,C,D,E,F).
snd_conj__5(','(A,B),C,D) :- 
    fst__6(C,D).
fst__6(A,A).
    
The trick to extract a slice from this is to see every conjunction
 as generating code for the first atom of the conjunction. I.e., the code for 
eq_conj__2(A,B,C) :- eq([],D1), app(D1,A,E1), len(E1,F1), snd(B,G1), fst(','(F1,G1),C).
would be
 eq([],[]).
or
 eq(X,X).   if we do not want instantiations in the slice.
 
and a call to eq_conj__2(A,B,C). would be expanded into a call to all its atoms,
 i.e., 
foo__1(A,B,C) :- 
    eq_conj__2(A,B,C).
    becomes
foo(A,B,C) :- eq([],D1), app(D1,A,E1), len(E1,F1), snd(B,G1), fst(','(F1,G1),C).

Also, if a predicate p occurs in multiple conjunctions, we take the clauses of p
that are used in at least one unfolding of p. I.e., we remove from the original
program only those clauses that are used in no unfolding of p.
 
We this we have solved the problem of propagation for this example.
From the SLD-tree for the conjunction 
  app_conj__3(A,B,C) :- app([],A,D1), len(D1,E1), snd(B,F1), fst(','(E1,F1),C).
which only unfolds app([],A,B) we can infer code for app which is simply
  app([],A,A).

The only thing that we cannot remove is the call to snd, and the code for snd.
Indeed, in order to remove it in the LP context we need to be sure that snd cannot
fail! And in this case snd could fail, so its code has to be retained.

If we use the slicing criterion
  foo([],Y,(Z1,Z2),W)
 we get:

/* Specialised program generated by Ecce 1.1 *//* PD Goal: foo([],A,(B,C),D) */
/* Parameters: Abs:m InstCheck:v Msv:n NgSlv:g Part:c Prun:n Sel:c Whstl:m
 Raf:yesFar:yes Dce:no Poly:n Dpu:no ParAbs:yes Msvp:no Rrc:no */
/* Transformation time: 50 ms */
/* Unfolding time: 30 ms */
/* Post-Processing time: 0 ms */

/* Specialised Predicates: 
foo__1(A,B,C,D) :- foo([],A,','(B,C),D).
eq_conj__2(A,B) :- eq([],C1), app(C1,A,D1), len(D1,E1), snd(','(F1,G1),H1), fst(','(E1,H1),B).
app_conj__3(A,B) :- app([],A,C1), len(C1,D1), snd(','(E1,F1),G1), fst(','(D1,G1),B).
len_conj__4(A,B,C,D) :- len(A,B), snd(','(E1,F1),G1), fst(','(C,G1),D).
snd_conj__5(A,B) :- snd(','(C1,D1),E1), fst(','(A,E1),B).
fst__6(A,B) :- fst(','(A,C1),B).
*/

foo([],A,','(B,C),D) :- 
    foo__1(A,B,C,D).
foo__1(A,B,C,D) :- 
    eq_conj__2(A,D).
eq_conj__2(A,B) :- 
    app_conj__3(A,B).
app_conj__3(A,B) :- 
    len_conj__4(A,C,C,B).
len_conj__4([],zero,A,B) :- 
    snd_conj__5(A,B).
len_conj__4([A|B],succ(C),D,E) :- 
    len_conj__4(B,C,D,E).
snd_conj__5(A,B) :- 
    fst__6(A,B).
fst__6(A,A).

By inspecting
snd_conj__5(A,B) :- snd(','(C1,D1),E1), fst(','(A,E1),B).
we see that all arguments to snd are arguments which are existential
(this is the RAF + FAR argument filterings which infers that).
The code for snd(','(C1,D1),E1) would thus be
 snd__5.
and we can remove it as it does nothing.

(The same holds if I change the original code for snd to something like:
   snd((_,Y),b).
 The RAF filtering has inferred that the result of snd is not used.)
 
 
Note, without RAF filtering I get:

snd_conj__5(A,B,C,D) :- snd(','(E1,A),B), fst(','(C,B),D).

without FAR filtering I get:

snd_conj__5(A,B,C,D) :- snd(','(A,B),E1), fst(','(C,E1),D).

So, I guess we need both FAR + RAF filtering to be able to safely remove
 snd from the slice.
 
 
I don't know whether this will yield a general solution, and anyway it might
be that such cases are pretty rare in LP, even though common in lazy FP. 
Have to think further about this.
 

================================

Actually, thinking about it: I have another idea how to do slicing in PD.
Just do PD, in any way you like. Then simply keep track of which clauses have
been used in the unfoldings, and throw away all which have not been used.

E.g., using the standard settings of ecce (but all post-processing turned off)
 I get the following specialised  program for foo([],A,B,C):

/* Specialised Predicates: 
foo__1(A,B,C) :- foo([],A,B,C).
len__2(A,B) :- len(A,B).
*/

foo([],A,B,C) :- 
    foo__1(A,B,C).
foo__1([],','(A,B),zero).
foo__1([A|B],','(C,D),succ(E)) :- 
    len__2(B,E).
len__2([],zero).
len__2([A|B],succ(C)) :- 
    len__2(B,C).

    
Not much of a slice: but I have adapted the printing of the original program
so that it removes all clauses that have not been used and I get:
    

1: foo(A,B,C,D) :- 
    eq(A,E), 
    app(E,B,F), 
    len(F,G), 
    snd(C,H), 
    fst(','(G,H),D).
2: len([],zero).
3: len([A|B],succ(C)) :- 
    len(B,C).
4: app([],A,A).
5:  REMOVED 
6: fst(','(A,B),A).
7: snd(','(A,B),B).


This is very similar in effect to what Gallagher & de Waal did in their paper
on removing redundant clauses. They do so using regular type analysis.
Ecce can now use bottom-up answer propagation as well, so we might get a very
powerful slicer ?
I think it is pretty straightforward to prove that this slice is executable
and yields the same result.

I still have to think about how to remove snd in case we specialise for
 foo([],Y,(_,_),W).
 
 
 For your second example,
map(_,[],[]).
map(P,[H|T],[PH|PT]) :-
        Call =.. [P,H,PH],
        call(Call),
        map(P,T,PT).

filter(_,[],[]).
filter(P,[H|T],[H2|FT]) :-
        Call =.. [P,H], 
        call(Call),!,
        inc(H,H2),
        filter(P,T,FT).
filter(P,[_|T],FT) :-
        filter(P,T,FT).

inc(X,Y) :- Y is X+1.

times3(X,Y) :- Y is X*3.
greater100(X) :- X>100.


slice1(L,R) :- map(times3,[],L), filter(greater100,L,R).
slice2(L,R) :- map(times3,[1,2,3],L), filter(greater100,L,R).

 I get the specialised program
 (again standard settings of ecce, but all post-processing turned off):
 
/* slice1__1(A,B) --> [slice1(A,B)] */
slice1__1([],[]).

and the slice:

1: map(A,[],[]).
2:  REMOVED 
3: filter(A,[],[]).
4:  REMOVED 
5:  REMOVED 
6:  REMOVED 
7:  REMOVED 
8:  REMOVED 
9: slice1(A,B) :- 
    map(times3,[],A), 
    filter(greater100,A,B).
10:  REMOVED 

which is what we would expect.


For the second slicing criterion I get the specialised program
 (standard settings of ecce, but all post-processing turned off):

/* Specialised Predicates: 
slice2__1(A,B) :- slice2(A,B).
filter__2(A) :- filter(greater100,[6,9],A).
filter__3(A) :- filter(greater100,[9],A).
*/

slice2(A,B) :-  slice2__1(A,B).

/* slice2__1(A,B) --> [slice2(A,B)] */
slice2__1([3,6,9],A) :- filter__2(A).

/* filter__2(A) --> [filter(greater100,[6,9],A)] */
filter__2(A) :- filter__3(A).

/* filter__3(A) --> [filter(greater100,[9],A)] */
filter__3([]).


and the slice:


1: map(A,[],[]).
2: map(A,[B|C],[D|E]) :- 
    F =.. '.'(A,[B,D]), 
    call(F), 
    map(A,C,E).
3: filter(A,[],[]).
4:  REMOVED 
5: filter(A,[B|C],D) :- 
    filter(A,C,D).
6:  REMOVED 
7: times3(A,B) :- 
    B is '*'(A,3).
8:  REMOVED 
9:  REMOVED 
10: slice2(A,B) :- 
    map(times3,[1,2,3],A), 
    filter(greater100,A,B).
    
    
So: inc, greater100 has been removed and the then part of the if-then-else.
Things seem to be working fine !! (so far ;-) )

So, it seems that this approach works and allows any PD strategy to be used.
I will try your other examples tomorrow (hopefully).

I guess in general one needs to apply RAF+FAR to the generated slices to see
whether one can remove certain arguments.

Best,
Michael
